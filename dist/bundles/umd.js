!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).pbkdf2Hmac=t()}(this,(function(){"use strict";const e={"SHA-1":{outputLength:20,blockSize:64},"SHA-256":{outputLength:32,blockSize:64},"SHA-384":{outputLength:48,blockSize:128},"SHA-512":{outputLength:64,blockSize:128}};function t(...e){const t=e.reduce(((e,t)=>e+t.length),0);if(0===e.length)throw new RangeError("Cannot concat no arrays");const n=new Uint8Array(t);let r=0;for(const t of e)n.set(t,r),r+=t.length;return n}function n(e,t){for(let n=0;n<e.length;n++)e[n]^=t[n]}return function(r,o,i,a,s="SHA-256"){return new Promise(((f,u)=>{s in e||u(new RangeError(`Valid hash algorithm values are any of ${Object.keys(e).toString()}`)),"string"==typeof r?r=(new TextEncoder).encode(r):r instanceof ArrayBuffer?r=new Uint8Array(r):ArrayBuffer.isView(r)||u(RangeError("P should be string, ArrayBuffer, TypedArray, DataView")),"string"==typeof o?o=(new TextEncoder).encode(o):o instanceof ArrayBuffer?o=new Uint8Array(o):ArrayBuffer.isView(o)?o=new Uint8Array(o.buffer,o.byteOffset,o.byteLength):u(RangeError("S should be string, ArrayBuffer, TypedArray, DataView")),crypto.subtle.importKey("raw",r,"PBKDF2",!1,["deriveBits"]).then((c=>{const y={name:"PBKDF2",hash:s,salt:o,iterations:i};crypto.subtle.deriveBits(y,c,8*a).then((e=>f(e)),(c=>{(async function(r,o,i,a,s){if(!(s in e))throw new RangeError(`Valid hash algorithm values are any of ${Object.keys(e).toString()}`);if(!Number.isInteger(i)||i<=0)throw new RangeError("c must be a positive integer");const f=e[s].outputLength;if(!Number.isInteger(a)||a<=0||a>=(2**32-1)*f)throw new RangeError("dkLen must be a positive integer < (2 ** 32 - 1) * hLen");const u=Math.ceil(a/f),c=a-(u-1)*f,y=new Array(u);0===r.byteLength&&(r=new Uint8Array(e[s].blockSize));const l=await crypto.subtle.importKey("raw",r,{name:"HMAC",hash:{name:s}},!0,["sign"]),h=async function(e,t){const n=await crypto.subtle.sign("HMAC",e,t);return new Uint8Array(n)};for(let e=0;e<u;e++)y[e]=await g(l,o,i,e+1);async function g(e,r,o,i){function a(e){const t=new ArrayBuffer(4);return new DataView(t).setUint32(0,e,!1),new Uint8Array(t)}const s=await h(e,t(r,a(i)));let f=s;for(let t=1;t<o;t++)f=await h(e,f),n(s,f);return s}return y[u-1]=y[u-1].slice(0,c),t(...y).buffer})(r,o,i,a,s).then((e=>f(e)),(e=>u(e)))}))}),(e=>u(e)))}))}}));
