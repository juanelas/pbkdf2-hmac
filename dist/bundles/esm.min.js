const e={"SHA-1":{outputLength:20,blockSize:64},"SHA-256":{outputLength:32,blockSize:64},"SHA-384":{outputLength:48,blockSize:128},"SHA-512":{outputLength:64,blockSize:128}};function t(t,a,o,i,s="SHA-256"){return new Promise(((u,c)=>{s in e||c(new RangeError(`Valid hash algorithm values are any of ${Object.keys(e).toString()}`)),"string"==typeof t?t=(new TextEncoder).encode(t):t instanceof ArrayBuffer?t=new Uint8Array(t):ArrayBuffer.isView(t)||c(RangeError("P should be string, ArrayBuffer, TypedArray, DataView")),"string"==typeof a?a=(new TextEncoder).encode(a):a instanceof ArrayBuffer?a=new Uint8Array(a):ArrayBuffer.isView(a)?a=new Uint8Array(a.buffer,a.byteOffset,a.byteLength):c(RangeError("S should be string, ArrayBuffer, TypedArray, DataView")),crypto.subtle.importKey("raw",t,"PBKDF2",!1,["deriveBits"]).then((f=>{const y={name:"PBKDF2",hash:s,salt:a,iterations:o};crypto.subtle.deriveBits(y,f,8*i).then((e=>u(e)),(f=>{(async function(t,a,o,i,s){if(!(s in e))throw new RangeError(`Valid hash algorithm values are any of ${Object.keys(e).toString()}`);if(!Number.isInteger(o)||o<=0)throw new RangeError("c must be a positive integer");const u=e[s].outputLength;if(!Number.isInteger(i)||i<=0||i>=(2**32-1)*u)throw new RangeError("dkLen must be a positive integer < (2 ** 32 - 1) * hLen");const c=Math.ceil(i/u),f=i-(c-1)*u,y=new Array(c);0===t.byteLength&&(t=new Uint8Array(e[s].blockSize));const w=await crypto.subtle.importKey("raw",t,{name:"HMAC",hash:{name:s}},!0,["sign"]),g=async function(e,t){const r=await crypto.subtle.sign("HMAC",e,t);return new Uint8Array(r)};for(let e=0;e<c;e++)y[e]=await h(w,a,o,e+1);async function h(e,t,a,o){function i(e){const t=new ArrayBuffer(4);return new DataView(t).setUint32(0,e,!1),new Uint8Array(t)}const s=await g(e,r(t,i(o)));let u=s;for(let t=1;t<a;t++)u=await g(e,u),n(s,u);return s}return y[c-1]=y[c-1].slice(0,f),r(...y).buffer})(t,a,o,i,s).then((e=>u(e)),(e=>c(e)))}))}),(e=>c(e)))}))}function r(...e){const t=e.reduce(((e,t)=>e+t.length),0);if(0===e.length)throw new RangeError("Cannot concat no arrays");const r=new Uint8Array(t);let n=0;for(const t of e)r.set(t,n),n+=t.length;return r}function n(e,t){for(let r=0;r<e.length;r++)e[r]^=t[r]}export{t as default};
